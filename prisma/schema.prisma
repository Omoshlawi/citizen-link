// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id            String   @id
  name          String
  email         String
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime
  voided        Boolean  @default(false)

  role       String?
  banned     Boolean?
  banReason  String?
  banExpires DateTime?

  username        String?
  displayUsername String?

  // relationshipd
  sessions       Session[]
  accounts       Account[]
  notifications  Notification[]
  messages       Message[]
  ratings        Rating[]
  cases          DocumentCase[]
  addresses      Address[]
  userActivities UserActivity[]
  claims         Claim[]
  aiinteractions AIInteraction[]
  transactions   Transaction[]

  twoFactorEnabled    Boolean?           @default(false)
  phoneNumber         String?
  phoneNumberVerified Boolean?
  twofactors          TwoFactor[]
  claimAttachments    ClaimAttachment[]
  statusTransitions   StatusTransition[]

  @@unique([email])
  @@unique([username])
  @@unique([phoneNumber])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  voided    Boolean  @default(false)

  impersonatedBy String?

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime
  voided                Boolean   @default(false)

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?
  voided     Boolean   @default(false)

  @@index([identifier])
  @@map("verification")
}

model Jwks {
  id         String   @id
  publicKey  String
  privateKey String
  createdAt  DateTime

  @@map("jwks")
}

model UserActivity {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  action      String // e.g., "create", "update", "delete", "view"
  resource    String // e.g., "screening", "client", "referral"
  resourceId  String? // ID of the affected resource
  metadata    Json? // Additional data about the activity
  description String? // Human-readable description of the activity
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
  @@index([resource, resourceId])
  @@map("user_activities")
}

model EntitySequence {
  id        String   @id @default(uuid())
  prefix    String   @unique // "CLM", "MCH", "INV", "TRX", etc.
  lastSeq   Int      @default(0)
  updatedAt DateTime @updatedAt

  @@map("entity_sequences")
}

// Universal Address Model with Hierarchical Support
model Address {
  id String @id @default(uuid())

  // Polymorphic ownership
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Address metadata
  type  AddressType @default(OTHER)
  label String? // e.g., "Home", "Office", "Billing"

  // Street-level details
  address1 String // Building/house number and street
  address2 String? // Apartment, suite, floor, etc.
  landmark String? // Nearby landmark or directions

  // Administrative Hierarchy (flexible for any country)
  // These fields adapt to local naming conventions
  level1 String // County (Kenya), State (US), Province (Canada)
  level2 String? // Sub-County (Kenya), City (US), District
  level3 String? // Ward (Kenya), Borough, Municipality  
  level4 String? // Village/Estate (Kenya), Neighborhood
  level5 String? // Additional granularity if needed

  // Legacy/common fields (for backward compatibility)
  cityVillage   String? // Maps to appropriate level
  stateProvince String? // Maps to appropriate level

  country    String  @default("KE") // ISO 3166-1 alpha-2 code (KE, US, etc.)
  postalCode String?

  // Geolocation
  latitude  Decimal?
  longitude Decimal?
  plusCode  String? // Google Plus Code for precise location

  // Temporal tracking
  startDate DateTime  @default(now())
  endDate   DateTime?

  // Metadata
  preferred Boolean @default(false)
  formatted String? // Cached formatted address

  // Locale-specific configuration
  localeId String?
  locale   AddressLocale? @relation(fields: [localeId], references: [id])

  cases DocumentCase[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  voided Boolean @default(false)
  claims Claim[]

  // For hierarchical queries
  @@index([userId])
  @@index([userId, preferred])
  @@index([country])
  @@index([localeId])
  @@index([level1, level2, level3])
  @@map("addresses")
}

enum AddressType {
  HOME
  WORK
  BILLING
  SHIPPING
  OFFICE
  OTHER
}

// Optional: Address Hierarchy Configuration (for dropdowns/autocomplete)

model AddressHierarchy {
  id       String             @id @default(uuid())
  country  String // ISO country code
  level    Int // 1, 2, 3, 4, 5
  parentId String? // Reference to parent level
  parent   AddressHierarchy?  @relation("Hierarchy", fields: [parentId], references: [id])
  children AddressHierarchy[] @relation("Hierarchy")

  code      String // Unique code (e.g., "KE-30" for Nairobi County)
  name      String // Display name
  nameLocal String? // Local language name

  voided Boolean @default(false)

  @@unique([country, code])
  @@index([country, level])
  @@index([parentId])
  @@map("address_hierarchy")
}

model AddressLocale {
  id          String   @id @default(uuid())
  code        String   @unique // Human readable code, e.g., "us-default"
  country     String // ISO country code e.g., "US"
  regionName  String // Friendly label for locale e.g., "United States (Default)"
  description String?
  formatSpec  Json // JSON schema describing level labels, ordering, required fields
  examples    Json? // Sample addresses, hints, etc.
  tags        String[] @default([]) // quick filters (urban, rural, etc.)

  addresses Address[]

  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  voided         Boolean         @default(false)
  pickupStations PickupStation[]

  @@index([country])
  @@index([regionName])
  @@map("address_locales")
}

model TransitionReason {
  id          String  @id @default(uuid())
  code        String
  entityType  String  @default("*") /// Which entity this applies to (Match, Claim, etc.)
  fromStatus  String  @default("*") // Status we are transitioning FROM (nullable for global reasons like OTHER)
  toStatus    String  @default("*") // Status we are transitioning TO (nullable for global reasons like OTHER)
  auto        Boolean @default(false) // Whether the reason is system-generated
  label       String // Short UI label
  description String? // Longer explanation for logs/admin UI
  metadata    Json? // Additional metadata for custom reasons

  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  statusTransitions StatusTransition[]
  voided            Boolean            @default(false)

  // Prevent duplicates for same entity + from + to + code
  @@unique([entityType, fromStatus, toStatus, code])
  @@index([entityType])
  @@index([entityType, fromStatus, toStatus])
  @@index([toStatus])
  @@map("transition_reasons")
}

model StatusTransition {
  id String @id @default(uuid())

  entityId   String // Match ID, Claim ID, etc.
  entityType String // "Match", "Match"

  fromStatus String
  toStatus   String

  reasonId String?
  reason   TransitionReason? @relation(fields: [reasonId], references: [id])

  comment String?

  changedById String
  changedBy   User   @relation(fields: [changedById], references: [id])

  createdAt DateTime @default(now())

  @@index([entityId, entityType])
  @@map("status_transitions")
}

// Document Types Enum - referenced by DocumentType model

enum DocumentCategory {
  IDENTITY // National IDs, Passports, Alien Cards, etc.
  ACADEMIC // Student IDs, Certificates, Transcripts
  PROFESSIONAL // Professional Licenses, Work Permits, etc.
  VEHICLE // Driver's Licenses, Vehicle Registration, etc.
  FINANCIAL // Bank Cards, Insurance Cards, etc.
  MEDICAL // NHIF Cards, Health Records, Vaccination Cards
  LEGAL // Title Deeds, Marriage Certificates, etc.
  OTHER // Any other documents
}

model DocumentType {
  id                      String           @id @default(uuid())
  name                    String           @unique // e.g., "National ID", "Passport", "Driver's License"
  category                DocumentCategory
  description             String?
  icon                    String?
  loyaltyPoints           Int // Points to award user who finds an post the document
  serviceFee              Decimal          @default(0) @db.Decimal(10, 2)
  finderReward            Decimal          @default(0) @db.Decimal(10, 2) // Amount rewarded to finder
  totalAmount             Decimal          @default(0) @db.Decimal(10, 2) // Service fee + finder reward
  currency                String           @default("KES")
  createdAt               DateTime         @default(now())
  updatedAt               DateTime         @updatedAt
  replacementInstructions String?
  averageReplacementCost  Float?
  documents               Document[]
  voided                  Boolean          @default(false)

  // AI Extraction Configuration
  aiExtractionPrompt String? @db.Text // Custom prompt for this doc type

  // AI Verification Configuration
  verificationStrategy Json // How AI should verify: { "strictFields": ["idNumber"], "flexibleFields": ["name"] }

  @@map("document_types")
}

// Common fields in PII Docs, helpfull in narrowing down search as cases grow and grow larger hence reducing primsps as well
// E.g will look for docs with certain field values then on that naroowed search, perfom ai matching 

model Document {
  id             String  @id @default(uuid())
  // Common Document Identifiers
  documentNumber String? // Generic document number (ID number, passport number, etc.)
  serialNumber   String? // Secondary identifier like serial number if present
  batchNumber    String? // Batch number if available

  // Owner Personal Details (as they appear on document)
  dateOfBirth  DateTime? // Owner's date of birth
  placeOfBirth String? // Owner's place of birth
  gender       String? // Owner's gender
  ownerName    String?

  issuer       String?
  // Document Type Information
  typeId       String
  type         DocumentType                @relation(fields: [typeId], references: [id], onDelete: Cascade)
  caseId       String                      @unique
  case         DocumentCase                @relation(fields: [caseId], onDelete: Cascade, references: [id])
  issuanceDate DateTime?
  placeOfIssue String?
  expiryDate   DateTime?
  note         String? // Additional notes
  embedding    Unsupported("vector(768)")?

  createdAt        DateTime        @default(now())
  images           DocumentImage[]
  additionalFields DocumentField[]

  @@map("documents")
}

// Dynamic Field Values - stores actual values for document-specific fields

model DocumentField {
  id         String   @id @default(uuid())
  documentId String
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  fieldName  String
  fieldValue String // All values stored as strings and converted as needed

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([documentId, fieldName])
  @@map("document_fields")
}

model DocumentImage {
  id         String    @id @default(uuid())
  url        String    @unique
  blurredUrl String? // Privacy-protected version
  aiAnalysis Json? // { "quality": 0.95, "readability": 0.88, "tampering_detected": false }
  documentId String?
  imageType  String? // Front, Back, Full, etc.
  // ocrText    String? // Raw OCR text extracted from this image // Included in metadat
  metadata   Json? // Additional metadata including ocrText(whn using seperate ocr to extratc text from image e.g tessaract), ai processing results, (size, format, etc.)
  document   Document? @relation(fields: [documentId], references: [id])
  createdAt  DateTime  @default(now())

  @@map("document_images")
}

//  AI INTERACTION LOGS
model AIInteraction {
  id String @id @default(uuid())

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Interaction Type
  interactionType AIInteractionType

  // AI Model Info
  aiModel      String
  modelVersion String?

  // Context - What entity triggered this AI call
  entityType String? // "LostDocument", "Match", "Claim", etc.
  entityId   String?

  // Request/Response
  prompt   String @db.Text
  response String @db.Text

  // Performance & Cost Tracking
  tokenUsage     Json? // { "input": 1500, "output": 800, "total": 2300 }
  processingTime Int? // milliseconds
  estimatedCost  Float? // Cost in USD (calculated from token usage)

  // Status
  success      Boolean @default(true)
  errorMessage String? @db.Text
  retryCount   Int     @default(0)

  createdAt              DateTime                  @default(now())
  extractionInteractions AIExtractionInteraction[]
  match                  Match?
  // aiverification         ClaimVerification?

  // For analytics and cost tracking
  // Quick filtering of failed requests
  @@index([userId])
  @@index([interactionType])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@index([success])
  @@map("ai_interactions")
}

enum AIInteractionType {
  DATA_EXTRACTION // Extracting data from found document images
  CONFIDENCE_SCORE // Calculating confidence score for extracted data
  DOCUMENT_MATCHING // Finding matches between lost and found
  CLAIM_VERIFICATION // Verifying user's security answers
  IMAGE_ANALYSIS // Analyzing document image quality/authenticity
  SECURITY_QUESTIONS_GEN // Generating security questions
  DISPUTE_ANALYSIS // Analyzing disputes
  USER_QUERY_RESPONSE // Responding to user questions/chat
  ALTERNATIVE_MATCHES // Finding alternative matches when user rejects
}

model AIExtraction {
  id String @id @default(uuid())

  createdAt DateTime @default(now())

  aiextractionInteractions AIExtractionInteraction[]
  documentCases            DocumentCase[]

  @@map("ai_extractions")
}

model AIExtractionInteraction {
  id              String        @id @default(uuid())
  // Related ai Interaction
  aiInteractionId String
  aiInteraction   AIInteraction @relation(fields: [aiInteractionId], references: [id], onDelete: Cascade)

  // Related ai extraction
  aiExtractionId String
  aiExtraction   AIExtraction @relation(fields: [aiExtractionId], references: [id], onDelete: Cascade)

  extractionData Json? // Parsed extracted fields 

  // Interaction and prompt might pass but parsing/validating ai response might fail hance status fields
  success      Boolean @default(true)
  errorMessage String? @db.Text

  extractionType AIExtractionInteractionType

  createdAt DateTime @default(now())

  @@map("ai_extraction_interactions")
}

enum AIExtractionInteractionType {
  DATA_EXTRACTION
  CONFIDENCE_SCORE
  IMAGE_ANALYSIS
  SECURITY_QUESTIONS
}

model DocumentCase {
  id         String   @id @default(uuid())
  caseNumber String   @unique
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  eventDate  DateTime // Lost or found date
  // Location information
  addressId  String
  address    Address  @relation(fields: [addressId], references: [id], onDelete: Cascade)

  // Related Extraction
  extractionId String?
  extraction   AIExtraction? @relation(fields: [extractionId], references: [id])

  tags        Json    @default("[]") // array of key words
  description String?

  // Relationship fields
  lostDocumentCase  LostDocumentCase?
  foundDocumentCase FoundDocumentCase?
  document          Document?
  notifications     Notification[]
  statusTransitions CaseStatusTransition[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  voided    Boolean  @default(false)

  // images         DocumentImage[]
  // notifications  Notification[]
  @@index([eventDate])
  @@map("document_cases")
}

// Lost Report model for documents reported lost

model LostDocumentCase {
  id        String                 @id @default(uuid())
  caseId    String                 @unique
  case      DocumentCase           @relation(fields: [caseId], references: [id], onDelete: Cascade)
  status    LostDocumentCaseStatus @default(DRAFT)
  createdAt DateTime               @default(now())
  updatedAt DateTime               @updatedAt
  matches   Match[]

  @@map("lost_document_cases")
}

// Found Report model for documents that were found

model FoundDocumentCase {
  id String @id @default(uuid())

  // Related Case
  caseId String       @unique
  case   DocumentCase @relation(fields: [caseId], references: [id], onDelete: Cascade)

  status           FoundDocumentCaseStatus @default(DRAFT)
  createdAt        DateTime                @default(now())
  updatedAt        DateTime                @updatedAt
  pointAwarded     Int                     @default(0) // Set when found document is succesfully united by the owner, is based on points awardable based on document type
  securityQuestion Json?                   @default("[]")
  matches          Match[]
  claims           Claim[]
  pickupStation    PickupStation?          @relation(fields: [pickupStationId], references: [id])
  pickupStationId  String?

  @@map("found_document_cases")
}

enum LostDocumentCaseStatus {
  DRAFT
  SUBMITTED // When user submit lost document info
  COMPLETED // When the document is reunited with the owner
}

enum FoundDocumentCaseStatus {
  DRAFT // When the document is in draft status
  SUBMITTED // When the document is submitted by the user to pickup station/point but not yet verified by the admin
  VERIFIED // When the document is verified by the admin
  REJECTED // When the document is rejected by the admin
  COMPLETED // When the document is reunited with the owner
}

// Status Transition History - tracks all status changes for audit and IoT integration

model CaseStatusTransition {
  id     String       @id @default(uuid())
  caseId String
  case   DocumentCase @relation(fields: [caseId], references: [id], onDelete: Cascade)

  // Status transition details
  fromStatus String // Previous status (null for initial status)
  toStatus   String // New status
  caseType   CaseType // LOST or FOUND

  // Actor information - who/what made the change
  actorType ActorType // USER, ADMIN, DEVICE, SYSTEM
  actorId   String? // User ID, Device ID, or null for SYSTEM
  actorName String? // Human-readable name (device name, user name, etc.)

  // IoT Device specific fields (when actorType is DEVICE)
  deviceId       String? // IoT device identifier
  deviceLocation String? // Physical location of device
  deviceMetadata Json? // Additional device info (firmware version, sensor readings, etc.)

  // Verification/Processing metadata
  verificationResult Json? // For IoT devices: verification results, confidence scores, etc.
  notes              String? // Human-readable notes or reason for transition

  // Metadata for flexibility
  metadata Json? // Additional context (API request details, batch processing info, etc.)

  createdAt DateTime @default(now())

  @@index([caseId])
  @@index([caseId, caseType])
  @@index([actorType, actorId])
  @@index([toStatus])
  @@index([createdAt])
  @@map("case_status_transitions")
}

enum CaseType {
  LOST
  FOUND
}

enum ActorType {
  USER // Regular user action
  ADMIN // Admin user action
  DEVICE // IoT device or automated system
  SYSTEM // System/automated process (matching, scheduled tasks, etc.)
}

// Match model for potential matches between lost and found reports

model Match {
  id          String @id @default(uuid())
  matchNumber String @unique

  aiInteractionId String        @unique
  aiInteraction   AIInteraction @relation(fields: [aiInteractionId], references: [id], onDelete: Cascade)

  lostDocumentCaseId  String
  foundDocumentCaseId String
  lostDocumentCase    LostDocumentCase  @relation(fields: [lostDocumentCaseId], references: [id], onDelete: Cascade)
  foundDocumentCase   FoundDocumentCase @relation(fields: [foundDocumentCaseId], references: [id], onDelete: Cascade)

  // AI Matching Results
  matchScore Float // 0-100, AI-determined confidence

  // Consolidated AI Analysis (all matching metadata in one place)
  aiAnalysis Json        @db.Json
  // Complete structure: {
  //   "reasoning": "Documents match based on identical ID numbers and names...",
  //   "fieldComparison": {
  //     "idNumber": { "match": true, "confidence": 0.99, "reasoning": "Exact match" },
  //     "name": { "match": true, "confidence": 0.92, "reasoning": "Names reversed but semantically identical" }
  //   },
  //   "riskFactors": { "low_image_quality": false, "partial_match": false },
  // }
  status     MatchStatus @default(PENDING)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  // Notification
  notifiedAt DateTime?
  viewedAt   DateTime?

  // Relations
  claims Claim[]

  voided Boolean @default(false)

  @@unique([lostDocumentCaseId, foundDocumentCaseId])
  @@index([status])
  @@map("matches")
}

enum MatchStatus {
  PENDING // Match found, awaiting user action
  REJECTED // User rejected match
  CLAIMED // User claimed this match
}

model Claim {
  id          String @id @default(uuid())
  claimNumber String @unique

  // Claimant
  userId String // Redundant field but kept for optimization through index and ease of querying
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Found Document Case
  foundDocumentCaseId String // redundant field but kept for optimization through index and ease of querying
  foundDocumentCase   FoundDocumentCase @relation(fields: [foundDocumentCaseId], references: [id], onDelete: Cascade)

  matchId String
  match   Match  @relation(fields: [matchId], references: [id], onDelete: Cascade)

  // Pickup Details
  pickupStationId String?
  pickupStation   PickupStation? @relation(fields: [pickupStationId], references: [id], onDelete: Cascade)
  pickupAddressId String?
  pickupAddress   Address?       @relation(fields: [pickupAddressId], references: [id], onDelete: Cascade)

  preferredHandoverDate DateTime?

  // Status
  status ClaimStatus @default(PENDING)

  // Relations
  invoice  Invoice?
  handover Handover?

  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  verification ClaimVerification?
  attachments  ClaimAttachment[] // Support document attachments

  @@index([userId])
  @@index([foundDocumentCaseId])
  @@index([matchId])
  @@index([status])
  @@map("claims")
}

enum ClaimStatus {
  PENDING
  VERIFIED
  CANCELLED
  REJECTED
  DISPUTED
  UNDER_REVIEW
}

model ClaimAttachment {
  id      String @id @default(uuid())
  claimId String
  claim   Claim  @relation(fields: [claimId], references: [id], onDelete: Cascade)

  storageKey   String
  uploadedById String
  uploadedBy   User   @relation(fields: [uploadedById], onDelete: Cascade, references: [id])

  createdAt DateTime @default(now())

  @@map("claim_attachments")
}

model ClaimVerification {
  id String @id @default(uuid())

  claimId String @unique
  claim   Claim  @relation(fields: [claimId], references: [id], onDelete: Cascade)

  userResponses Json // User's answers to security questions

  // Result
  passed    Boolean
  createdAt DateTime @default(now())

  @@index([claimId])
  @@map("claim_verifications")
}

model PickupStation {
  id   String @id @default(uuid())
  code String @unique // hUMAN FRIENDLY i dentifier e.g KE-NRB-CBD-001
  name String

  addressLocaleCode String
  addressLocale     AddressLocale @relation(fields: [addressLocaleCode], references: [code], onDelete: Cascade)

  country    String  @default("KE") // ISO 3166-1 alpha-2 code (KE, US, etc.)
  postalCode String?

  // Street-level details
  address1 String // Building/house number and street
  address2 String? // Apartment, suite, floor, etc.
  landmark String? // Nearby landmark or directions

  // Administrative Hierarchy (flexible for any country)
  level1      String // County (Kenya), State (US), Province (Canada)
  level2      String? // Sub-County (Kenya), City (US), District
  level3      String? // Ward (Kenya), Borough, Municipality  
  level4      String? // Village/Estate (Kenya), Neighborhood
  level5      String? // Additional granularity if needed
  coordinates Json

  phoneNumber String?
  email       String?
  formatted   String? // Cached formatted address
  voided      Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Operating Hours
  operatingHours Json?

  // Relations
  foundDocumentCases FoundDocumentCase[]
  claims             Claim[]
  handovers          Handover[]

  @@map("pickup_stations")
}

model Handover {
  id             String @id @default(uuid())
  handoverNumber String @unique

  claimId String @unique
  claim   Claim  @relation(fields: [claimId], references: [id])

  pickupStationId String
  pickupStation   PickupStation @relation(fields: [pickupStationId], references: [id])

  // Scheduling
  scheduledDate DateTime
  completedAt   DateTime?

  // Verification at pickup
  ownerVerified Boolean @default(false)
  finderPresent Boolean @default(false)

  // Documentation
  ownerSignature  String?
  finderSignature String?
  handoverNotes   String? @db.Text

  status HandoverStatus @default(SCHEDULED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([claimId])
  @@index([status])
  @@map("handovers")
}

enum HandoverStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

// 2. The Invoice acts as the "Bill" and tracks the lipa mdogo mdogo progress
model Invoice {
  id            String @id @default(uuid())
  invoiceNumber String @unique

  claimId String @unique // 1-to-1 relationship retained!
  claim   Claim  @relation(fields: [claimId], references: [id], onDelete: Cascade)

  // Use Decimal for money!
  serviceFee   Decimal @db.Decimal(10, 2)
  finderReward Decimal @db.Decimal(10, 2)
  totalAmount  Decimal @db.Decimal(10, 2)

  // Tracking installments
  amountPaid Decimal @default(0.00) @db.Decimal(10, 2)
  balanceDue Decimal @db.Decimal(10, 2) // totalAmount - amountPaid

  status InvoiceStatus @default(PENDING)

  // 1-to-Many relationship with Transactions
  transactions Transaction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([claimId])
  @@index([status])
  @@map("invoices")
}

enum InvoiceStatus {
  PENDING
  PARTIALLY_PAID
  PAID
  CANCELLED
}

model Transaction {
  id                String @id @default(uuid())
  transactionNumber String @unique

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  // The amount for this specific installment/attempt
  amount   Decimal @db.Decimal(10, 2)
  currency String  @default("KES")

  // Payment Details
  paymentMethod         PaymentMethod
  paymentProvider       String?
  providerTransactionId String? // e.g., M-Pesa Receipt Number

  status TransactionStatus @default(PENDING)

  // Metadata
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([invoiceId])
  @@index([userId])
  @@index([status])
  @@map("transactions")
}

enum PaymentMethod {
  CARD
  MOBILE_MONEY
  BANK_TRANSFER
  WALLET
}

enum TransactionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

model Rating {
  id String @id @default(uuid())

  // Rater
  raterId String
  rater   User   @relation(fields: [raterId], references: [id], onDelete: Cascade)

  // Rating Details
  rating Int // 1-5 stars
  review String? @db.Text

  // AI Sentiment Analysis (optional)
  aiSentiment Json? // AI analyzes review sentiment and flags concerns

  // Context
  claimId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([raterId])
  @@map("ratings")
}

model Notification {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type    NotificationType
  title   String
  message String           @db.Text

  // Related Entity
  relatedId   String?
  relatedType String?

  // Delivery
  read   Boolean   @default(false)
  readAt DateTime?

  // Channels
  sentViaEmail Boolean @default(false)
  sentViaSMS   Boolean @default(false)
  sentViaPush  Boolean @default(false)

  createdAt      DateTime      @default(now())
  documentCase   DocumentCase? @relation(fields: [documentCaseId], references: [id])
  documentCaseId String?

  @@index([userId])
  @@index([read])
  @@index([type])
  @@map("notifications")
}

enum NotificationType {
  MATCH_FOUND
  CLAIM_VERIFIED
  PAYMENT_RECEIVED
  PICKUP_READY
  HANDOVER_SCHEDULED
  HANDOVER_COMPLETED
  RATING_RECEIVED
  DOCUMENT_EXPIRED
  SYSTEM_ALERT
}

// Message model for communication between users

model Message {
  id            String   @id @default(uuid())
  sender        User     @relation(fields: [senderId], references: [id])
  senderId      String
  content       String
  attachmentUrl String?
  createdAt     DateTime @default(now())
  isRead        Boolean  @default(false)
  voided        Boolean  @default(false)

  conversationId String

  @@index([senderId])
  @@index([conversationId])
  @@index([createdAt])
  @@map("messages")
}

// Conversation model for grouping messages

model Conversation {
  id            String    @id @default(uuid())
  participants  String // Array of user IDs
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastMessageAt DateTime?
  title         String?
  voided        Boolean   @default(false)

  @@index([participants])
  @@map("conversations")
}

// FAQ model

model FAQ {
  id       String  @id @default(uuid())
  question String
  answer   String
  category String
  order    Int
  isActive Boolean @default(true)
  voided   Boolean @default(false)

  @@map("faqs")
}

// System Settings

model Setting {
  id          String   @id @default(uuid())
  key         String   @unique
  value       String
  description String?
  updatedAt   DateTime @updatedAt
  updatedBy   String?
  voided      Boolean  @default(false)

  @@map("settings")
}

model TwoFactor {
  id          String @id
  secret      String
  backupCodes String
  userId      String
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("twoFactor")
}
