// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id            String   @id
  name          String
  email         String
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime
  voided        Boolean  @default(false)

  role       String?
  banned     Boolean?
  banReason  String?
  banExpires DateTime?

  username        String?
  displayUsername String?

  // relationshipd
  sessions       Session[]
  accounts       Account[]
  notifications  Notification[]
  messages       Message[]
  ratings        Rating[]
  cases          DocumentCase[]
  addresses      Address[]
  userActivities UserActivity[]
  claims         Claim[]
  aiinteractions AIInteraction[]
  transactions   Transaction[]
  disputes       Dispute[]

  twoFactorEnabled    Boolean?    @default(false)
  phoneNumber         String?
  phoneNumberVerified Boolean?
  twofactors          TwoFactor[]

  @@unique([email])
  @@unique([username])
  @@unique([phoneNumber])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  voided    Boolean  @default(false)

  impersonatedBy String?

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime
  voided                Boolean   @default(false)

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?
  voided     Boolean   @default(false)

  @@index([identifier])
  @@map("verification")
}

model Jwks {
  id         String   @id
  publicKey  String
  privateKey String
  createdAt  DateTime

  @@map("jwks")
}

model UserActivity {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  action      String // e.g., "create", "update", "delete", "view"
  resource    String // e.g., "screening", "client", "referral"
  resourceId  String? // ID of the affected resource
  metadata    Json? // Additional data about the activity
  description String? // Human-readable description of the activity
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
  @@index([resource, resourceId])
  @@map("user_activity")
}

// Universal Address Model with Hierarchical Support

model Address {
  id String @id @default(uuid())

  // Polymorphic ownership
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Address metadata
  type  AddressType @default(OTHER)
  label String? // e.g., "Home", "Office", "Billing"

  // Street-level details
  address1 String // Building/house number and street
  address2 String? // Apartment, suite, floor, etc.
  landmark String? // Nearby landmark or directions

  // Administrative Hierarchy (flexible for any country)
  // These fields adapt to local naming conventions
  level1 String // County (Kenya), State (US), Province (Canada)
  level2 String? // Sub-County (Kenya), City (US), District
  level3 String? // Ward (Kenya), Borough, Municipality  
  level4 String? // Village/Estate (Kenya), Neighborhood
  level5 String? // Additional granularity if needed

  // Legacy/common fields (for backward compatibility)
  cityVillage   String? // Maps to appropriate level
  stateProvince String? // Maps to appropriate level

  country    String // ISO 3166-1 alpha-2 code (KE, US, etc.)
  postalCode String?

  // Geolocation
  latitude  Decimal?
  longitude Decimal?
  plusCode  String? // Google Plus Code for precise location

  // Temporal tracking
  startDate DateTime  @default(now())
  endDate   DateTime?

  // Metadata
  preferred Boolean @default(false)
  formatted String? // Cached formatted address

  // Locale-specific configuration
  localeId String?
  locale   AddressLocale? @relation(fields: [localeId], references: [id])

  cases DocumentCase[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  voided Boolean @default(false)

  // For hierarchical queries
  @@index([userId])
  @@index([userId, preferred])
  @@index([country])
  @@index([localeId])
  @@index([level1, level2, level3])
}

enum AddressType {
  HOME
  WORK
  BILLING
  SHIPPING
  OFFICE
  OTHER
}

// Optional: Address Hierarchy Configuration (for dropdowns/autocomplete)

model AddressHierarchy {
  id       String             @id @default(uuid())
  country  String // ISO country code
  level    Int // 1, 2, 3, 4, 5
  parentId String? // Reference to parent level
  parent   AddressHierarchy?  @relation("Hierarchy", fields: [parentId], references: [id])
  children AddressHierarchy[] @relation("Hierarchy")

  code      String // Unique code (e.g., "KE-30" for Nairobi County)
  name      String // Display name
  nameLocal String? // Local language name

  voided Boolean @default(false)

  @@unique([country, code])
  @@index([country, level])
  @@index([parentId])
}

model AddressLocale {
  id          String   @id @default(uuid())
  code        String   @unique // Human readable code, e.g., "us-default"
  country     String // ISO country code e.g., "US"
  regionName  String // Friendly label for locale e.g., "United States (Default)"
  description String?
  formatSpec  Json // JSON schema describing level labels, ordering, required fields
  examples    Json? // Sample addresses, hints, etc.
  tags        String[] @default([]) // quick filters (urban, rural, etc.)

  addresses Address[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  voided    Boolean  @default(false)

  @@index([country])
  @@index([regionName])
}

// Document Types Enum - referenced by DocumentType model

enum DocumentCategory {
  IDENTITY // National IDs, Passports, Alien Cards, etc.
  ACADEMIC // Student IDs, Certificates, Transcripts
  PROFESSIONAL // Professional Licenses, Work Permits, etc.
  VEHICLE // Driver's Licenses, Vehicle Registration, etc.
  FINANCIAL // Bank Cards, Insurance Cards, etc.
  MEDICAL // NHIF Cards, Health Records, Vaccination Cards
  LEGAL // Title Deeds, Marriage Certificates, etc.
  OTHER // Any other documents
}

model DocumentType {
  id                      String           @id @default(uuid())
  name                    String           @unique // e.g., "National ID", "Passport", "Driver's License"
  category                DocumentCategory
  description             String?
  icon                    String?
  loyaltyPoints           Int // Points to award user who finds an post the document
  createdAt               DateTime         @default(now())
  updatedAt               DateTime         @updatedAt
  replacementInstructions String?
  averageReplacementCost  Float?
  documents               Document[]
  voided                  Boolean          @default(false)

  // AI Extraction Configuration
  aiExtractionPrompt String? @db.Text // Custom prompt for this doc type

  // AI Verification Configuration
  verificationStrategy Json // How AI should verify: { "strictFields": ["idNumber"], "flexibleFields": ["name"] }
}

// Common fields in PII Docs, helpfull in narrowing down search as cases grow and grow larger hence reducing primsps as well
// E.g will look for docs with certain field values then on that naroowed search, perfom ai matching 

model Document {
  id             String  @id @default(uuid())
  // Common Document Identifiers
  documentNumber String? // Generic document number (ID number, passport number, etc.)
  serialNumber   String? // Secondary identifier like serial number if present
  batchNumber    String? // Batch number if available

  // Owner Personal Details (as they appear on document)
  dateOfBirth  DateTime? // Owner's date of birth
  placeOfBirth String? // Owner's place of birth
  gender       String? // Owner's gender
  ownerName    String?

  issuer       String?
  // Document Type Information
  typeId       String
  type         DocumentType           @relation(fields: [typeId], references: [id], onDelete: Cascade)
  caseId       String                 @unique
  case         DocumentCase           @relation(fields: [caseId], onDelete: Cascade, references: [id])
  issuanceDate DateTime?
  placeOfIssue String?
  expiryDate   DateTime?
  note         String? // Additional notes
  embedding    Unsupported("vector")?

  createdAt        DateTime        @default(now())
  images           Image[]
  additionalFields DocumentField[]
}

// Dynamic Field Values - stores actual values for document-specific fields

model DocumentField {
  id         String   @id @default(uuid())
  documentId String
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  fieldName  String
  fieldValue String // All values stored as strings and converted as needed

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([documentId, fieldName])
}

model Image {
  id         String    @id @default(uuid())
  url        String    @unique
  blurredUrl String? // Privacy-protected version
  aiAnalysis Json? // { "quality": 0.95, "readability": 0.88, "tampering_detected": false }
  documentId String?
  imageType  String? // Front, Back, Full, etc.
  // ocrText    String? // Raw OCR text extracted from this image // Included in metadat
  metadata   Json? // Additional metadata including ocrText(whn using seperate ocr to extratc text from image e.g tessaract), ai processing results, (size, format, etc.)
  document   Document? @relation(fields: [documentId], references: [id])
  createdAt  DateTime  @default(now())
}

model AIExtraction {
  id String @id @default(uuid())

  createdAt DateTime @default(now())

  aiextractionInteractions AIExtractionInteraction[]
  documentCases            DocumentCase[]
}

model AIExtractionInteraction {
  id              String        @id @default(uuid())
  // Related ai Interaction
  aiInteractionId String
  aiInteraction   AIInteraction @relation(fields: [aiInteractionId], references: [id], onDelete: Cascade)

  // Related ai extraction
  aiExtractionId String
  aiExtraction   AIExtraction @relation(fields: [aiExtractionId], references: [id], onDelete: Cascade)

  extractionData Json? // Parsed extracted fields 

  // Interaction and prompt might pass but parsing/validating ai response might fail hance status fields
  success      Boolean @default(true)
  errorMessage String? @db.Text

  extractionType AIExtractionInteractionType

  createdAt DateTime @default(now())
}

enum AIExtractionInteractionType {
  DATA_EXTRACTION
  CONFIDENCE_SCORE
  IMAGE_ANALYSIS
  SECURITY_QUESTIONS
}

model DocumentCase {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  eventDate DateTime // Lost or found date
  // Location information
  addressId String
  address   Address  @relation(fields: [addressId], references: [id], onDelete: Cascade)

  // Related Extraction
  extractionId String?
  extraction   AIExtraction? @relation(fields: [extractionId], references: [id])

  tags        Json    @default("[]") // array of key words
  description String?

  // Relationship fields
  lostDocumentCase  LostDocumentCase?
  foundDocumentCase FoundDocumentCase?
  document          Document?
  notifications     Notification[]
  statusTransitions CaseStatusTransition[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  voided    Boolean  @default(false)

  // images         Image[]
  // notifications  Notification[]
  @@index([eventDate])
}

// Lost Report model for documents reported lost

model LostDocumentCase {
  id        String                 @id @default(uuid())
  caseId    String                 @unique
  case      DocumentCase           @relation(fields: [caseId], references: [id], onDelete: Cascade)
  status    LostDocumentCaseStatus @default(DRAFT)
  createdAt DateTime               @default(now())
  updatedAt DateTime               @updatedAt
  matches   Match[]
}

// Found Report model for documents that were found

model FoundDocumentCase {
  id String @id @default(uuid())

  // Related Case
  caseId String       @unique
  case   DocumentCase @relation(fields: [caseId], references: [id], onDelete: Cascade)

  status           FoundDocumentCaseStatus @default(DRAFT)
  createdAt        DateTime                @default(now())
  updatedAt        DateTime                @updatedAt
  pointAwarded     Int                     @default(0) // Set when found document is succesfully united by the owner, is based on points awardable based on document type
  securityQuestion Json?                   @default("[]")
  matches          Match[]
  claims           Claim[]
  pickupStation    PickupStation?          @relation(fields: [pickupStationId], references: [id])
  pickupStationId  String?
}

enum LostDocumentCaseStatus {
  DRAFT
  SUBMITTED // When user submit lost document info
  COMPLETED // When the document is reunited with the owner
}

enum FoundDocumentCaseStatus {
  DRAFT // When the document is in draft status
  SUBMITTED // When the document is submitted by the user to pickup station/point but not yet verified by the admin
  VERIFIED // When the document is verified by the admin
  REJECTED // When the document is rejected by the admin
  COMPLETED // When the document is reunited with the owner
}

// Status Transition History - tracks all status changes for audit and IoT integration

model CaseStatusTransition {
  id     String       @id @default(uuid())
  caseId String
  case   DocumentCase @relation(fields: [caseId], references: [id], onDelete: Cascade)

  // Status transition details
  fromStatus String // Previous status (null for initial status)
  toStatus   String // New status
  caseType   CaseType // LOST or FOUND

  // Actor information - who/what made the change
  actorType ActorType // USER, ADMIN, DEVICE, SYSTEM
  actorId   String? // User ID, Device ID, or null for SYSTEM
  actorName String? // Human-readable name (device name, user name, etc.)

  // IoT Device specific fields (when actorType is DEVICE)
  deviceId       String? // IoT device identifier
  deviceLocation String? // Physical location of device
  deviceMetadata Json? // Additional device info (firmware version, sensor readings, etc.)

  // Verification/Processing metadata
  verificationResult Json? // For IoT devices: verification results, confidence scores, etc.
  notes              String? // Human-readable notes or reason for transition

  // Metadata for flexibility
  metadata Json? // Additional context (API request details, batch processing info, etc.)

  createdAt DateTime @default(now())

  @@index([caseId])
  @@index([caseId, caseType])
  @@index([actorType, actorId])
  @@index([toStatus])
  @@index([createdAt])
}

enum CaseType {
  LOST
  FOUND
}

enum ActorType {
  USER // Regular user action
  ADMIN // Admin user action
  DEVICE // IoT device or automated system
  SYSTEM // System/automated process (matching, scheduled tasks, etc.)
}

// Match model for potential matches between lost and found reports

model Match {
  id          String @id @default(uuid())
  matchNumber Int    @unique @default(autoincrement())

  aiInteractionId String        @unique
  aiInteraction   AIInteraction @relation(fields: [aiInteractionId], references: [id], onDelete: Cascade)

  lostDocumentCaseId  String
  foundDocumentCaseId String
  lostDocumentCase    LostDocumentCase  @relation(fields: [lostDocumentCaseId], references: [id], onDelete: Cascade)
  foundDocumentCase   FoundDocumentCase @relation(fields: [foundDocumentCaseId], references: [id], onDelete: Cascade)

  // AI Matching Results
  matchScore Float // 0-100, AI-determined confidence

  // Consolidated AI Analysis (all matching metadata in one place)
  aiAnalysis Json        @db.Json
  // Complete structure: {
  //   "reasoning": "Documents match based on identical ID numbers and names...",
  //   "fieldComparison": {
  //     "idNumber": { "match": true, "confidence": 0.99, "reasoning": "Exact match" },
  //     "name": { "match": true, "confidence": 0.92, "reasoning": "Names reversed but semantically identical" }
  //   },
  //   "riskFactors": { "low_image_quality": false, "partial_match": false },
  // }
  status     MatchStatus @default(PENDING)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  // Notification
  notifiedAt DateTime?
  viewedAt   DateTime?

  // Relations
  claims Claim[]

  voided Boolean @default(false)

  @@unique([lostDocumentCaseId, foundDocumentCaseId])
  @@index([status])
}

enum MatchStatus {
  PENDING // Match found, awaiting user action
  REJECTED // User rejected match
  CLAIMED // User claimed this match
  EXPIRED // Match expired without action
}

model Claim {
  id          String @id @default(uuid())
  claimNumber String @unique

  // Claimant
  userId String // Redundant field but kept for optimization through index and ease of querying
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Found Document Case
  foundDocumentCaseId String // redundant field but kept for optimization through index and ease of querying
  foundDocumentCase   FoundDocumentCase @relation(fields: [foundDocumentCaseId], references: [id], onDelete: Cascade)

  matchId String
  match   Match  @relation(fields: [matchId], references: [id])

  verificationStatus ClaimVerificationStatus @default(PENDING)

  // AI tracks all verification attempts
  // Pickup Details
  pickupStationId     String?
  pickupStation       PickupStation? @relation(fields: [pickupStationId], references: [id])
  preferredPickupDate DateTime?

  // 

  // Status
  status ClaimStatus @default(PENDING_VERIFICATION)

  // Fees & Payment
  serviceFee   Float @default(0)
  finderReward Float @default(0)
  totalAmount  Float @default(0)

  // Relations
  transaction Transaction?
  handover    Handover?
  dispute     Dispute?

  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  aiverification AIVerification?

  @@index([userId])
  @@index([foundDocumentCaseId])
  @@index([matchId])
  @@index([status])
}

enum ClaimVerificationStatus {
  PENDING
  VERIFIED
  FAILED
}

enum ClaimStatus {
  PENDING_VERIFICATION
  VERIFIED
  PAYMENT_PENDING
  PAYMENT_COMPLETE
  READY_FOR_PICKUP
  COMPLETED
  CANCELLED
  DISPUTED
}

model AIVerification {
  id String @id @default(uuid())

  claimId String @unique
  claim   Claim  @relation(fields: [claimId], references: [id], onDelete: Cascade)

  aiInteractionId String        @unique
  aiInteraction   AIInteraction @relation(fields: [aiInteractionId], onDelete: Cascade, references: [id])

  userResponses Json // User's answers to security questions

  // AI Analysis
  aiAnalysis Json // AI's detailed analysis of each answer
  // Example: {
  //   "questions": [
  //       {
  //         "question": "What is the name of the document owner"?
  //           "expected": "John Michael Doe",
  //           "provided": "Doe John Michael",
  //           "match": true,
  //           "confidence": 95,
  //           "reasoning": "Names reordered but all components present and correct"
  //         }
  //    ]
  // }

  // AI Decision
  overallVerdict  VerificationVerdict
  confidenceScore Float // 0-100, how confident AI is in its decision
  reasoning       String              @db.Text // AI explains its decision

  // Flexibility Factors AI Considered
  flexibilityApplied Json // What variations AI accepted: name order, spelling, formatting, etc.

  // Result
  passed Boolean

  createdAt DateTime @default(now())

  @@index([claimId])
}

enum VerificationVerdict {
  STRONG_MATCH // High confidence, clear match
  LIKELY_MATCH // Good confidence with acceptable variations
  UNCERTAIN // Low confidence, borderline
  NO_MATCH // Clear mismatch
  INSUFFICIENT_DATA // Can't determine
}

//  AI INTERACTION LOGS

model AIInteraction {
  id String @id @default(uuid())

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Interaction Type
  interactionType AIInteractionType

  // AI Model Info
  aiModel      String
  modelVersion String?

  // Context - What entity triggered this AI call
  entityType String? // "LostDocument", "Match", "Claim", etc.
  entityId   String?

  // Request/Response
  prompt   String @db.Text
  response String @db.Text

  // Performance & Cost Tracking
  tokenUsage     Json? // { "input": 1500, "output": 800, "total": 2300 }
  processingTime Int? // milliseconds
  estimatedCost  Float? // Cost in USD (calculated from token usage)

  // Status
  success      Boolean @default(true)
  errorMessage String? @db.Text
  retryCount   Int     @default(0)

  createdAt              DateTime                  @default(now())
  extractionInteractions AIExtractionInteraction[]
  match                  Match?
  aiverification         AIVerification?

  // For analytics and cost tracking
  // Quick filtering of failed requests
  @@index([userId])
  @@index([interactionType])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@index([success])
}

enum AIInteractionType {
  DATA_EXTRACTION // Extracting data from found document images
  CONFIDENCE_SCORE // Calculating confidence score for extracted data
  DOCUMENT_MATCHING // Finding matches between lost and found
  CLAIM_VERIFICATION // Verifying user's security answers
  IMAGE_ANALYSIS // Analyzing document image quality/authenticity
  SECURITY_QUESTIONS_GEN // Generating security questions
  DISPUTE_ANALYSIS // Analyzing disputes
  USER_QUERY_RESPONSE // Responding to user questions/chat
  ALTERNATIVE_MATCHES // Finding alternative matches when user rejects
}

model PickupStation {
  id      String  @id @default(uuid())
  name    String
  code    String  @unique
  address String
  city    String
  region  String?

  // Contact
  phone String
  email String?

  // Location
  latitude  Float?
  longitude Float?

  // Operating Hours
  operatingHours Json

  // Capacity
  isActive Boolean @default(true)

  // Relations
  foundDocumentCases FoundDocumentCase[]
  claims             Claim[]
  handovers          Handover[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([code])
  @@index([city])
}

model Handover {
  id             String @id @default(uuid())
  handoverNumber String @unique

  claimId String @unique
  claim   Claim  @relation(fields: [claimId], references: [id])

  pickupStationId String
  pickupStation   PickupStation @relation(fields: [pickupStationId], references: [id])

  // Scheduling
  scheduledDate DateTime
  completedAt   DateTime?

  // Verification at pickup
  ownerVerified Boolean @default(false)
  finderPresent Boolean @default(false)

  // Documentation
  ownerSignature  String?
  finderSignature String?
  handoverNotes   String? @db.Text

  status HandoverStatus @default(SCHEDULED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([claimId])
  @@index([status])
}

enum HandoverStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

// Notification model for user alerts

model Transaction {
  id                String @id @default(uuid())
  transactionNumber String @unique

  userId String
  user   User   @relation(fields: [userId], references: [id])

  claimId String @unique
  claim   Claim  @relation(fields: [claimId], references: [id])

  // Amounts
  serviceFee   Float
  finderReward Float
  platformFee  Float @default(0)
  totalAmount  Float

  // Payment Details
  paymentMethod         PaymentMethod
  paymentProvider       String?
  providerTransactionId String?

  status TransactionStatus @default(PENDING)

  // Metadata
  metadata Json?

  paidAt     DateTime?
  refundedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([claimId])
  @@index([status])
}

enum PaymentMethod {
  CARD
  MOBILE_MONEY
  BANK_TRANSFER
  WALLET
}

enum TransactionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

model Rating {
  id String @id @default(uuid())

  // Rater
  raterId String
  rater   User   @relation(fields: [raterId], references: [id], onDelete: Cascade)

  // Rating Details
  rating Int // 1-5 stars
  review String? @db.Text

  // AI Sentiment Analysis (optional)
  aiSentiment Json? // AI analyzes review sentiment and flags concerns

  // Context
  claimId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([raterId])
}

model Notification {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type    NotificationType
  title   String
  message String           @db.Text

  // Related Entity
  relatedId   String?
  relatedType String?

  // Delivery
  read   Boolean   @default(false)
  readAt DateTime?

  // Channels
  sentViaEmail Boolean @default(false)
  sentViaSMS   Boolean @default(false)
  sentViaPush  Boolean @default(false)

  createdAt      DateTime      @default(now())
  documentCase   DocumentCase? @relation(fields: [documentCaseId], references: [id])
  documentCaseId String?

  @@index([userId])
  @@index([read])
  @@index([type])
}

enum NotificationType {
  MATCH_FOUND
  CLAIM_VERIFIED
  PAYMENT_RECEIVED
  PICKUP_READY
  HANDOVER_SCHEDULED
  HANDOVER_COMPLETED
  RATING_RECEIVED
  DOCUMENT_EXPIRED
  SYSTEM_ALERT
}

model Dispute {
  id            String @id @default(uuid())
  disputeNumber String @unique

  claimId String @unique
  claim   Claim  @relation(fields: [claimId], references: [id])

  initiatedBy String
  initiator   User   @relation(fields: [initiatedBy], references: [id])

  reason      String @db.Text
  description String @db.Text
  evidence    Json?

  // AI Analysis
  aiAnalysis Json? // AI analyzes dispute and suggests resolution

  status     DisputeStatus @default(OPEN)
  resolution String?       @db.Text
  resolvedBy String?
  resolvedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([claimId])
  @@index([status])
}

enum DisputeStatus {
  OPEN
  INVESTIGATING
  RESOLVED
  CLOSED
}

// Message model for communication between users

model Message {
  id            String   @id @default(uuid())
  sender        User     @relation(fields: [senderId], references: [id])
  senderId      String
  content       String
  attachmentUrl String?
  createdAt     DateTime @default(now())
  isRead        Boolean  @default(false)
  voided        Boolean  @default(false)

  conversationId String

  @@index([senderId])
  @@index([conversationId])
  @@index([createdAt])
}

// Conversation model for grouping messages

model Conversation {
  id            String    @id @default(uuid())
  participants  String // Array of user IDs
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastMessageAt DateTime?
  title         String?
  voided        Boolean   @default(false)

  @@index([participants])
}

// FAQ model

model FAQ {
  id       String  @id @default(uuid())
  question String
  answer   String
  category String
  order    Int
  isActive Boolean @default(true)
  voided   Boolean @default(false)
}

// System Settings

model Setting {
  id          String   @id @default(uuid())
  key         String   @unique
  value       String
  description String?
  updatedAt   DateTime @updatedAt
  updatedBy   String?
  voided      Boolean  @default(false)
}

model TwoFactor {
  id          String @id
  secret      String
  backupCodes String
  userId      String
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("twoFactor")
}
